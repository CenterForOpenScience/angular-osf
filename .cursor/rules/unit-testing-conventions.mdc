---
description: Unit testing conventions for Angular component specs
globs: **/*.spec.ts
alwaysApply: false
---

# Unit Testing Conventions

## Store & Actions

- Use `provideMockStore()` from `@testing/providers/store-provider.mock` for all store mocking.
- Use `mergeSignalOverrides(defaults, overrides)` from the same module to apply selector overrides in `setup()` helpers — never inline the merge logic.
- Inject the mock store via `store = TestBed.inject(Store)` and assert on `store.dispatch`.
- Never use `Object.defineProperty` to mock `component.actions` — it bypasses `createDispatchMap` entirely.
- Only provide `actions` config in `provideMockStore({ actions: [...] })` when component logic reads the dispatch return value. The default `jest.fn()` returning `of(true)` is sufficient otherwise.
- Use `(store.dispatch as jest.Mock).mockClear()` when `ngOnInit` dispatches and you need clean assertions per test.

## Providers

- Use `provideOSFCore()` from `@testing/osf.testing.provider.ts` instead of `OSFTestingModule`.
- Use `MockProvider` from ng-mocks as the default for providing mock services: `MockProvider(ToastService, ToastServiceMock.simple())`.
- When the test needs `jest.fn()` methods (`.mockImplementation`, `.mockClear`, assertions), pass an explicit mock as the second argument — bare `MockProvider(Service)` creates ng-mocks stubs, not `jest.fn()`.
- Use builders from `@testing/providers/` to construct non-trivial mocks: `ActivatedRouteMockBuilder`, `RouterMockBuilder`, `CustomDialogServiceMockBuilder`. Pass the built result to `MockProvider`: `MockProvider(ActivatedRoute, ActivatedRouteMockBuilder.create().withParams({ id: '1' }).build())`.
- Use `withNoParent()` on `ActivatedRouteMockBuilder` when testing components that guard against a missing parent route — never cast `{ parent: null } as Partial<ActivatedRoute>` inline.
- Use `.simple()` factories for common mock shapes: `ToastServiceMock.simple()`, `CustomConfirmationServiceMock.simple()`.
- Use `provideDynamicDialogRefMock()` for dialog components — it creates a real `Subject` for `onClose` that `MockProvider` cannot auto-generate.
- Use `provideMockStore()` from `@testing/providers/store-provider.mock` for store mocking.
- Check `@testing/` for existing mocks and builders before creating inline mocks.

## Running Tests

- Run a specific spec file with `npm test <spec-name>`. Example: `npm test auth.interceptor.spec`.
- Add `--no-coverage` to skip the coverage report for faster feedback.
- The `working_directory` must be the workspace root (`d:\OSF\angular-osf`).

## Test Structure

- Prefer a single flat `describe` block per file to keep tests searchable and prevent state leakage. Use nested `describe` blocks when it significantly simplifies setup or groups logically distinct behaviors.
- For specs where all tests share a single configuration, use `beforeEach` with `TestBed.configureTestingModule` directly. Use a `setup()` helper when tests need different selector values, route configs, or other overrides.
- When using `setup()`, extend `BaseSetupOverrides` from `@testing/providers/store-provider.mock` for the standard route/selector shape. Add component-specific fields as needed.
- No `TestBed.resetTestingModule()` in `afterEach` — Angular auto-resets.
- No redundant tests — merge tests that cover the same code path.
- Use actual interfaces/types for mock data instead of `any`.
- Use `@docs/testing.md` for rules in unit testing.

## Example

```typescript
import { Store } from '@ngxs/store';
import { MockProvider } from 'ng-mocks';
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { ActivatedRoute, Router } from '@angular/router';
import { ToastService } from '@osf/shared/services/toast.service';
import { MySelectors, MyAction } from '@osf/features/my-feature/store';
import { MyComponent } from './my.component';
import { provideOSFCore } from '@testing/osf.testing.provider';
import { ActivatedRouteMockBuilder } from '@testing/providers/route-provider.mock';
import { RouterMockBuilder, RouterMockType } from '@testing/providers/router-provider.mock';
import { provideMockStore } from '@testing/providers/store-provider.mock';
import { ToastServiceMock, ToastServiceMockType } from '@testing/providers/toast-provider.mock';

describe('MyComponent', () => {
  let component: MyComponent;
  let fixture: ComponentFixture<MyComponent>;
  let store: Store;
  let mockRouter: RouterMockType;
  let toastService: ToastServiceMockType;

  beforeEach(() => {
    const mockRoute = ActivatedRouteMockBuilder.create().withParams({ id: '1' }).build();
    mockRouter = RouterMockBuilder.create().withUrl('/x').build();
    toastService = ToastServiceMock.simple();

    TestBed.configureTestingModule({
      imports: [MyComponent],
      providers: [
        provideOSFCore(),
        MockProvider(ActivatedRoute, mockRoute),
        MockProvider(Router, mockRouter),
        MockProvider(ToastService, toastService),
        provideMockStore({
          signals: [{ selector: MySelectors.getData, value: [] }],
        }),
      ],
    });

    store = TestBed.inject(Store);
    fixture = TestBed.createComponent(MyComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });

  it('should dispatch action and show toast', () => {
    component.doSomething();
    expect(store.dispatch).toHaveBeenCalledWith(new MyAction('1'));
    expect(toastService.showSuccess).toHaveBeenCalledWith('done');
  });
});
```
